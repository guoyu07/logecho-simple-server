// Generated by CoffeeScript 1.7.1
(function() {
  var CHECK_INTERVAL, RELEASE_INTERVAL, argv, data, decode, denied, dispatcher, getHandler, http, https, isSecure, jade, logger, md5, message, mime, options, pathInfo, performResource, pool, postHandler, respond, retry, server, url, uuid, winston, zlib,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  http = require('http');

  https = require('https');

  url = require('url');

  zlib = require('zlib');

  pathInfo = require('path');

  uuid = require('node-uuid');

  jade = require('jade');

  winston = require('winston');

  md5 = require('MD5');

  argv = require('optimist')["default"]('k', uuid.v4())["default"]('h', '0.0.0.0')["default"]('p', null)["default"]('200', __dirname + '/../template/200.jade')["default"]('404', __dirname + '/../template/404.jade')["default"]('403', __dirname + '/../template/403.jade')["default"]('500', __dirname + '/../template/500.jade')["default"]('503', __dirname + '/../template/503.jade')["default"]('prefer-host', null)["default"]('ip-address', null)["default"]('http-to-https', null)["default"]('https-key', null)["default"]('https-cert', null)["default"]('perform-resource', 'yes').argv;

  logger = new winston.Logger({
    transports: [
      new winston.transports.Console({
        handleExceptions: true,
        level: 'info',
        prettyPrint: true,
        colorize: true,
        timestamp: true
      })
    ],
    exitOnError: false,
    levels: {
      info: 0,
      warn: 1,
      error: 3
    },
    colors: {
      info: 'green',
      warn: 'yellow',
      error: 'red'
    }
  });

  data = null;

  isSecure = (argv['https-key'] != null) && (argv['https-cert'] != null);

  message = {
    200: 'OK',
    403: 'Forbidden',
    404: 'Not Found',
    500: 'Internal Server Error',
    503: 'Service Unavailable'
  };

  mime = {
    'html': 'text/html',
    'htm': 'text/html',
    'css': 'text/css',
    'js': 'application/x-javascript',
    'xml': 'text/xml',
    'gif': 'image/gif',
    'jpeg': 'image/jpeg',
    'jpg': 'image/jpeg',
    'jpe': 'image/jpeg',
    'tif': 'image/tiff',
    'tiff': 'image/tiff',
    'png': 'image/png',
    'svg': 'image/svg+xml',
    'svgz': 'image/svg+xml',
    'ico': 'image/x-icon',
    'txt': 'text/plain',
    'text': 'text/plain'
  };

  denied = [];

  retry = {};

  pool = {};

  CHECK_INTERVAL = 60000;

  RELEASE_INTERVAL = 86400000;

  if (argv.p == null) {
    argv.p = argv.s != null ? 443 : 80;
  }

  performResource = function(path, str, type, hashes) {
    var replace;
    replace = function(link) {
      var dir, hash, info, normalizedPath, root;
      if (link.match(/^[_a-z0-9-]+:/i || link.match(/^\/\//))) {
        return link;
      }
      info = url.parse(link);
      dir = pathInfo.dirname(path);
      root = path.match(/^\./) ? dir : '';
      normalizedPath = pathInfo.normalize(root + info.pathname);
      if (hashes[normalizedPath] == null) {
        return link;
      }
      hash = hashes[normalizedPath];
      link = info.pathname + '?h=' + hash;
      if (info.hash != null) {
        link += info.hash;
      }
      return link;
    };
    switch (type) {
      case 'text/html':
        str = str.replace(/<link([^>]+)href="([^"]+)"([^>]*)>/ig, function(m, a, link, b) {
          link = replace(link);
          return "<link" + a + "href=\"" + link + "\"" + b + ">";
        });
        str = str.replace(/<img([^>]+)src="([^"]+)"([^>]*)>/ig, function(m, a, link, b) {
          link = replace(link);
          return "<img" + a + "src=\"" + link + "\"" + b + ">";
        });
        break;
      case 'text/css':
        str = str.replace(/url\(([^\)]+)\)/ig, function(m, link) {
          link = replace(link);
          return "url(" + link + ")";
        });
        break;
      default:
        break;
    }
    return str;
  };

  decode = function(buff, ip) {
    var ext, hashes, item, line, lines, newData, path, str, suffix, type, v, _i, _len, _ref;
    lines = buff.split("\n");
    newData = {};
    hashes = {};
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      _ref = line.split(' '), path = _ref[0], v = _ref[1];
      str = new Buffer(v, 'base64').toString('utf8');
      ext = (pathInfo.extname(path)).substring(1);
      type = mime[ext] ? mime[ext] : (ext.length > 0 ? 'text/plain' : 'application/octet-stream');
      suffix = null;
      if (type.match(/^text\//)) {
        suffix = '; charset=UTF-8';
      }
      if (argv['perform-resource'] === 'yes') {
        hashes[path] = md5(v);
      }
      newData[path] = {
        body: str,
        type: type,
        suffix: suffix,
        time: new Date().toUTCString(),
        cache: ext !== 'html' && ext !== 'htm' && ext !== 'xml' && ext !== 'txt' && ext !== 'text'
      };
    }
    if (argv['perform-resource'] === 'yes') {
      for (path in newData) {
        item = newData[path];
        newData[path].body = performResource(path, item.body, item.type, hashes);
      }
    }
    data = newData;
    return logger.info("Published contents form address " + ip);
  };

  respond = function(item, req, res) {
    var body, cache, encoding, pipe;
    body = null;
    cache = false;
    if (!(item instanceof Object)) {
      res.statusCode = item;
      res.statusMessage = message[item];
      res.setHeader('Content-Type', 'text/html; charset=UTF8');
      body = jade.renderFile(argv[item + '']);
    } else {
      res.setHeader('Content-Type', item.type + item.suffix);
      body = item.body;
      cache = item.cache;
    }
    if (cache) {
      res.setHeader('Cache-Control', 'max-age=259200');
      res.setHeader('Last-Modified', item.time);
    } else {
      res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0');
      res.setHeader('Pragma', 'no-cache');
    }
    encoding = req.headers['accept-encoding'];
    if (!encoding) {
      encoding = '';
    }
    encoding = encoding.split(/\s*,\s*/);
    pipe = res;
    if (__indexOf.call(encoding, 'deflate') >= 0) {
      res.setHeader('Content-Encoding', 'deflate');
      pipe = zlib.createDeflate();
      pipe.pipe(res);
    } else if (__indexOf.call(encoding, 'gzip') >= 0) {
      res.setHeader('Content-Encoding', 'gzip');
      pipe = zlib.createGzip();
      pipe.pipe(res);
    }
    pipe.write(body);
    return pipe.end();
  };

  dispatcher = function(req, res) {
    var info;
    info = url.parse(req.url, true);
    if (req.method === 'GET') {
      return getHandler(info, req, res);
    } else if (req.method === 'POST') {
      return postHandler(info, req, res);
    }
  };

  getHandler = function(info, req, res) {
    var host, path, preferHost, redirectUrl;
    preferHost = argv['prefer-host'];
    if (preferHost != null) {
      host = req.headers.host.split(':');
      if (preferHost.toLowerCase() !== host[0].toLowerCase()) {
        host[0] = preferHost;
        redirectUrl = isSecure ? 'https' : 'http';
        redirectUrl += '://' + (host.join(':')) + req.url;
        res.statusCode = 301;
        res.statusMessage = 'Moved Permanently';
        res.setHeader('Location', redirectUrl);
      }
    }
    if (data == null) {
      respond(503, req, res);
      return;
    }
    path = info.pathname;
    if (path[path.length - 1] === '/') {
      path += 'index.html';
    }
    if (data[path] != null) {
      return respond(data[path], req, res);
    } else {
      return respond(404, req, res);
    }
  };

  postHandler = function(info, req, res) {
    var buff, ip, key;
    key = req.headers.authorization;
    ip = req.connection.remoteAddress;
    if (argv['ip-address'] != null) {
      ip = req.headers[argv['ip-address'].toLowerCase()];
    }
    if (__indexOf.call(denied, ip) >= 0 || (key == null)) {
      return respond(403, req, res);
    }
    key = (new Buffer((key.split(' '))[1], 'base64').toString().split(':'))[0];
    if (key === argv.k) {
      buff = '';
      req.on('data', function(chunk) {
        return buff += chunk.toString();
      });
      return req.on('end', function() {
        respond(200, req, res);
        return decode(buff, ip);
      });
    } else {
      respond(403, req, res);
      if (retry[ip] == null) {
        retry[ip] = 0;
      }
      retry[ip] += 1;
      pool[ip] = Date.now();
      if (retry[ip] > 3 && __indexOf.call(denied, ip) < 0) {
        return denied.push(ip);
      }
    }
  };

  setInterval(function() {
    var ip, k, now, v, _i, _len, _results;
    now = Date.now();
    for (ip in retry) {
      if (now - pool[ip] > RELEASE_INTERVAL) {
        delete retry[ip];
      } else {
        break;
      }
    }
    for (_i = 0, _len = denied.length; _i < _len; _i++) {
      ip = denied[_i];
      if (now - pool[ip] > RELEASE_INTERVAL) {
        denied.shift();
      } else {
        break;
      }
    }
    _results = [];
    for (k in pool) {
      v = pool[k];
      if (now - pool[ip] > RELEASE_INTERVAL) {
        _results.push(delete pool[ip]);
      } else {
        break;
      }
    }
    return _results;
  }, CHECK_INTERVAL);

  if (isSecure) {
    options = {
      key: fs.readFileSync(argv['https-key']),
      cert: fs.readFileSync(argv['https-cert'])
    };
    server = https.createServer(options, dispatcher);
  } else {
    server = http.createServer(dispatcher);
  }

  module.exports = function() {
    var redirectPort;
    server.listen(argv.p, argv.h);
    logger.info("The secure key is: " + argv.k);
    logger.info("Listening on " + argv.h + ":" + argv.p);
    if (argv['prefer-host'] != null) {
      logger.info("Http host is forcing to " + argv['prefer-host']);
    }
    redirectPort = argv['http-to-https'];
    if (isSecure && (redirectPort != null)) {
      redirectPort = redirectPort === 'yes' ? 80 : redirectPort;
      return http.createServer(function(req, res) {
        var redirectUrl;
        redirectUrl = 'https://' + req.headers.host + req.url;
        res.statusCode = 301;
        res.statusMessage = 'Moved Permanently';
        return res.setHeader('Location', redirectUrl);
      });
    }
  };

}).call(this);
