// Generated by CoffeeScript 1.7.1
(function() {
  var CHECK_INTERVAL, RELEASE_INTERVAL, argv, data, decode, denied, dispatcher, getHandler, http, jade, logger, message, mime, pool, postHandler, respond, retry, server, url, uuid, winston, zlib,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  http = require('http');

  url = require('url');

  zlib = require('zlib');

  uuid = require('node-uuid');

  jade = require('jade');

  winston = require('winston');

  argv = require('optimist')["default"]('k', uuid.v4())["default"]('h', '0.0.0.0')["default"]('p', null)["default"]('s', null)["default"]('404', __dirname + '/../template/404.jade')["default"]('403', __dirname + '/../template/403.jade')["default"]('500', __dirname + '/../template/500.jade')["default"]('503', __dirname + '/../template/503.jade').argv;

  logger = new winston.Logger({
    transports: [
      new winston.transports.Console({
        handleExceptions: true,
        level: 'info',
        prettyPrint: true,
        colorize: true,
        timestamp: true
      })
    ],
    exitOnError: false,
    levels: {
      info: 0,
      warn: 1,
      error: 3
    },
    colors: {
      info: 'green',
      warn: 'yellow',
      error: 'red'
    }
  });

  data = null;

  message = {
    403: 'Forbidden',
    404: 'Not Found',
    500: 'Internal Server Error',
    503: 'Service Unavailable'
  };

  mime = {
    'html': 'text/html',
    'htm': 'text/html',
    'css': 'text/css',
    'js': 'application/x-javascript',
    'xml': 'text/xml',
    'gif': 'image/gif',
    'jpeg': 'image/jpeg',
    'jpg': 'image/jpeg',
    'jpe': 'image/jpeg',
    'tif': 'image/tiff',
    'tiff': 'image/tiff',
    'png': 'image/png',
    'svg': 'image/svg+xml',
    'svgz': 'image/svg+xml',
    'ico': 'image/x-icon',
    'txt': 'text/plain',
    'text': 'text/plain'
  };

  denied = [];

  retry = {};

  pool = {};

  CHECK_INTERVAL = 3000;

  RELEASE_INTERVAL = 5000;

  if (argv.p == null) {
    argv.p = argv.s != null ? 443 : 80;
  }

  decode = function(buff, ip) {
    var ext, line, lines, newData, parts, path, str, suffix, type, v, _i, _len, _ref;
    lines = buff.split("\n");
    newData = {};
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      _ref = line.split(' '), path = _ref[0], v = _ref[1];
      str = new Buffer(v, 'base64').toString('utf8');
      parts = path.split('.');
      ext = parts[parts.length - 1].toLowerCase();
      type = mime[ext] ? mime[ext] : (parts.length > 1 ? 'text/plain' : 'application/octet-stream');
      suffix = null;
      if (type.match(/^text\//)) {
        suffix = '; charset=UTF-8';
      }
      newData[path] = {
        body: str,
        ext: ext,
        type: type,
        suffix: suffix
      };
    }
    data = newData;
    return logger.info("Published contents form address " + ip);
  };

  respond = function(str, req, res) {
    var encoding, pipe;
    if ((Number(str)) === str) {
      res.statusCode = str;
      res.statusMessage = message[str];
      str = jade.renderFile(argv[str + '']);
    }
    encoding = req.headers['accept-encoding'];
    if (!encoding) {
      encoding = '';
    }
    encoding = encoding.split(/\s*,\s*/);
    pipe = res;
    if (__indexOf.call(encoding, 'deflate') >= 0) {
      res.setHeader('Content-Encoding', 'deflate');
      pipe = zlib.createDeflate();
      pipe.pipe(res);
    } else if (__indexOf.call(encoding, 'gzip') >= 0) {
      res.setHeader('Content-Encoding', 'gzip');
      pipe = zlib.createGzip();
      pipe.pipe(res);
    }
    pipe.write(str);
    return pipe.end();
  };

  dispatcher = function(req, res) {
    var info;
    info = url.parse(req.url, true);
    if (req.method === 'GET') {
      return getHandler(info, req, res);
    } else if (req.method === 'POST') {
      return postHandler(info, req, res);
    }
  };

  getHandler = function(info, req, res) {
    var item, path;
    if (data == null) {
      respond(503, req, res);
      return;
    }
    path = info.pathname;
    if (path[path.length - 1] === '/') {
      path += 'index.html';
    }
    if (data[path] != null) {
      item = data[path];
      res.setHeader('Content-Type', item.type + item.suffix);
      return respond(item.body, req, res);
    } else {
      return respond(404, req, res);
    }
  };

  postHandler = function(info, req, res) {
    var buff, ip, key;
    ip = req.connection.remoteAddress;
    key = req.headers.authorization;
    if (__indexOf.call(denied, ip) >= 0 || (key == null)) {
      return respond(403, req, res);
    }
    key = (new Buffer((key.split(' '))[1], 'base64').toString().split(':'))[0];
    if (key === argv.k) {
      buff = '';
      req.on('data', function(chunk) {
        return buff += chunk.toString();
      });
      return req.on('end', function() {
        respond('OK', req, res);
        return decode(buff, ip);
      });
    } else {
      respond(403, req, res);
      if (retry[ip] == null) {
        retry[ip] = 0;
      }
      retry[ip] += 1;
      pool[ip] = Date.now();
      if (retry[ip] > 3 && __indexOf.call(denied, ip) < 0) {
        return denied.push(ip);
      }
    }
  };

  setInterval(function() {
    var ip, k, now, v, _i, _len, _results;
    now = Date.now();
    for (ip in retry) {
      if (now - pool[ip] > RELEASE_INTERVAL) {
        delete retry[ip];
      } else {
        break;
      }
    }
    for (_i = 0, _len = denied.length; _i < _len; _i++) {
      ip = denied[_i];
      if (now - pool[ip] > RELEASE_INTERVAL) {
        denied.shift();
      } else {
        break;
      }
    }
    _results = [];
    for (k in pool) {
      v = pool[k];
      if (now - pool[ip] > RELEASE_INTERVAL) {
        _results.push(delete pool[ip]);
      } else {
        break;
      }
    }
    return _results;
  }, CHECK_INTERVAL);

  server = http.createServer(dispatcher);

  module.exports = function() {
    server.listen(argv.p, argv.h);
    logger.info("The secure key is: " + argv.k);
    return logger.info("Listening on " + argv.h + ":" + argv.p);
  };

}).call(this);
